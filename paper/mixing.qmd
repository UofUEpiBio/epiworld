---
format: gfm
title: Mixing probabilities in connected model
author: George G. Vega Yon, Ph.D.
date: 2024-04-25
---

## Case 1: No grouping

We will look into the probability of drawing infected individuals to simplify the algorithm. There are $I$ infected individuals at any time in the simulation; thus, instead of drawing from $Bern(c/N, N)$, we will be drawing from $Bern(c/N, I)$. The next step is to check which infected individuals should be drawn. Let's compare the distributions using the hypergeometric as an example:


```{r}
#| label: Simulation
set.seed(132)
nsims <- 1e5
N <- 400
rate <- 2
p <- rate/N
I <- 10

sim_complex <- parallel::mclapply(1:nsims, \(i) {
  nsamples <- rbinom(N, N, p)
  sum(rhyper(N, m = I, n = N, k = nsamples) > 0)
}, mc.cores = 4L) |> unlist()

sim_simple <- parallel::mclapply(1:nsims, \(i) {
  sum(rbinom(N, I, p) > 0) 
}, mc.cores = 4L) |> unlist()


op <- par(mfrow = c(1,2))
MASS::truehist(sim_complex)
MASS::truehist(sim_simple)
par(op)

quantile(sim_complex)
quantile(sim_simple)
```

These two approaches are equivalent, but the second one is more efficient from the computational perspective.

## Case 2: Grouping

This explores the case when we have mixing across groups. The question is if we can replicate the effect at the group level.

```{r}
set.seed(123133)

ngroups <- 3
mixing <- matrix(
  c(0.1, 0.2, 0.3, 0.2, 0.1, 0.2, 0.3, 0.2, 0.1),
  nrow = ngroups,
  ncol = ngroups
  )

mixing <- mixing/rowSums(mixing)
mixing

N <- 500
sizes <- c(100, 50, 350)
rate <- 1
p <- rate/N
I <- c(10, 5, 20)

ids <- rep.int(1:ngroups, times = sizes)

nsims <- 2e5

sim_complex <- parallel::mclapply(1:nsims, \(i) {

  # Sampling how many
  nsamples <- rbinom(N, N, p)

  # Sampling group first
  where_from <- lapply(1:N, \(i) {
    groups <- sample(
      3, size = nsamples[i], replace = TRUE, prob = mixing[ids[i],]
      )
  })

  nsamples <- rbinom(N, sizes[where_from], p)
  sum(rhyper(N, m = I[where_from], n = sizes[where_from], k = nsamples) > 0)
}, mc.cores = 4L) |> unlist()
```

Using the alternative method in which we directly weight the probabilities:


```{r}
sim_simple <- parallel::mclapply(1:nsims, \(i) {

  res <- sapply(ids, \(g) {
    sum(rbinom(3, size = I, prob = mixing[g,] * p))
  }) 

  sum(res > 0)

}, mc.cores = 4L) |> unlist()

op <- par(mfrow = c(1,2))
MASS::truehist(sim_complex)
MASS::truehist(sim_simple)
par(op)

quantile(sim_complex)
quantile(sim_simple)

(table(sim_complex) |> prop.table() |> cumsum() -
  table(sim_simple) |> prop.table() |> cumsum()) |> plot()

```